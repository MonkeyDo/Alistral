use crate::core::entity_traits::mbid::IsMbid;
use crate::models::data::listenbrainz::user_listens::UserListens;
use crate::models::data::musicbrainz::mbid::extensions::VecTExt;
use crate::models::radio::RadioConfig;
use crate::utils::playlist::PlaylistStub;
use chrono::prelude::Utc;
use chrono::Duration;
use futures::stream;
use futures::StreamExt;
use itertools::Itertools;
use rust_decimal::prelude::Decimal;
use rust_decimal::prelude::FromPrimitive;

pub async fn overdue_radio(
    username: &str,
    token: &str,
    min_listens: Option<u64>,
    cooldown: u64,
    overdue_factor: bool,
    config: RadioConfig,
) -> color_eyre::Result<()> {
    let mut listens = UserListens::get_user_with_refresh(username)
        .await
        .expect("Couldn't fetch the new listens")
        .get_mapped_listens();

    let deadline = Utc::now() - Duration::hours(cooldown as i64);
    let blacklisted_recordings = listens
        .get_listened_after(&deadline)
        .get_listened_recordings_mbids()
        .await
        .unwrap();

    // Filter out all the listens of blacklisted recordings
    listens = listens
        .filter_recordings(&blacklisted_recordings, true, false)
        .await
        .unwrap();

    let mut rates = listens
        .get_listen_rates()
        .await
        .expect("Couldn't calculate the listens rates");

    // Filter minimum
    rates.retain(|rate| rate.1.listen_count() > &min_listens.unwrap_or(2_u64));

    // Get scores
    let scores = if !overdue_factor {
        rates
            .into_iter()
            .map(|(listens, rate)| {
                let time_elapsed_after_prediction =
                    Utc::now() - rate.get_estimated_date_of_next_listen(&listens);

                (
                    Decimal::from(time_elapsed_after_prediction.num_seconds()),
                    rate.recording().clone(),
                )
            })
            .collect_vec()
    } else {
        rates
            .into_iter()
            .map(|(listens, rate)| {
                let overdue_by =
                    Decimal::from_i64(rate.get_overdue_by(&listens).num_seconds()).unwrap();
                let time_for_listen =
                    Decimal::from_i64(rate.get_average_time_between_listens().num_seconds())
                        .unwrap();
                let overdue_factor = overdue_by / time_for_listen;

                (overdue_factor, rate.recording().clone())
            })
            .collect_vec()
    };

    let sorted_scores = RadioConfig::sort_scores(scores);

    let scores_as_recording = stream::iter(sorted_scores)
        .map(|recording_mbid| async move { recording_mbid.get_or_fetch_entity().await })
        .buffered(1);
    let playlist = config.finalize_radio_playlist(scores_as_recording).await?;

    PlaylistStub::new(
        "Radio: Overdue listens".to_string(),
        Some(username.to_string()),
        true,
        playlist.into_mbids(),
        Some(
            "Automatically generated by: https://github.com/RustyNova016/listenbrainz-cli-tools"
                .to_string(),
        ),
    )
    .send(token)
    .await?;

    Ok(())
}
